// Code generated by mockery. DO NOT EDIT.

package scheduler_mocks

import (
	gocron "github.com/go-co-op/gocron"
	mock "github.com/stretchr/testify/mock"

	scheduler "go.fork.vn/scheduler"

	time "time"
)

// MockManager is an autogenerated mock type for the Manager type
type MockManager struct {
	mock.Mock
}

type MockManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockManager) EXPECT() *MockManager_Expecter {
	return &MockManager_Expecter{mock: &_m.Mock}
}

// At provides a mock function with given fields: _a0
func (_m *MockManager) At(_a0 string) scheduler.Manager {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for At")
	}

	var r0 scheduler.Manager
	if rf, ok := ret.Get(0).(func(string) scheduler.Manager); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(scheduler.Manager)
		}
	}

	return r0
}

// MockManager_At_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'At'
type MockManager_At_Call struct {
	*mock.Call
}

// At is a helper method to define mock.On call
//   - _a0 string
func (_e *MockManager_Expecter) At(_a0 interface{}) *MockManager_At_Call {
	return &MockManager_At_Call{Call: _e.mock.On("At", _a0)}
}

func (_c *MockManager_At_Call) Run(run func(_a0 string)) *MockManager_At_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockManager_At_Call) Return(_a0 scheduler.Manager) *MockManager_At_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_At_Call) RunAndReturn(run func(string) scheduler.Manager) *MockManager_At_Call {
	_c.Call.Return(run)
	return _c
}

// Clear provides a mock function with no fields
func (_m *MockManager) Clear() {
	_m.Called()
}

// MockManager_Clear_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clear'
type MockManager_Clear_Call struct {
	*mock.Call
}

// Clear is a helper method to define mock.On call
func (_e *MockManager_Expecter) Clear() *MockManager_Clear_Call {
	return &MockManager_Clear_Call{Call: _e.mock.On("Clear")}
}

func (_c *MockManager_Clear_Call) Run(run func()) *MockManager_Clear_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockManager_Clear_Call) Return() *MockManager_Clear_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockManager_Clear_Call) RunAndReturn(run func()) *MockManager_Clear_Call {
	_c.Run(run)
	return _c
}

// Cron provides a mock function with given fields: cronExpression
func (_m *MockManager) Cron(cronExpression string) scheduler.Manager {
	ret := _m.Called(cronExpression)

	if len(ret) == 0 {
		panic("no return value specified for Cron")
	}

	var r0 scheduler.Manager
	if rf, ok := ret.Get(0).(func(string) scheduler.Manager); ok {
		r0 = rf(cronExpression)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(scheduler.Manager)
		}
	}

	return r0
}

// MockManager_Cron_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Cron'
type MockManager_Cron_Call struct {
	*mock.Call
}

// Cron is a helper method to define mock.On call
//   - cronExpression string
func (_e *MockManager_Expecter) Cron(cronExpression interface{}) *MockManager_Cron_Call {
	return &MockManager_Cron_Call{Call: _e.mock.On("Cron", cronExpression)}
}

func (_c *MockManager_Cron_Call) Run(run func(cronExpression string)) *MockManager_Cron_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockManager_Cron_Call) Return(_a0 scheduler.Manager) *MockManager_Cron_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_Cron_Call) RunAndReturn(run func(string) scheduler.Manager) *MockManager_Cron_Call {
	_c.Call.Return(run)
	return _c
}

// CronWithSeconds provides a mock function with given fields: cronExpression
func (_m *MockManager) CronWithSeconds(cronExpression string) scheduler.Manager {
	ret := _m.Called(cronExpression)

	if len(ret) == 0 {
		panic("no return value specified for CronWithSeconds")
	}

	var r0 scheduler.Manager
	if rf, ok := ret.Get(0).(func(string) scheduler.Manager); ok {
		r0 = rf(cronExpression)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(scheduler.Manager)
		}
	}

	return r0
}

// MockManager_CronWithSeconds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CronWithSeconds'
type MockManager_CronWithSeconds_Call struct {
	*mock.Call
}

// CronWithSeconds is a helper method to define mock.On call
//   - cronExpression string
func (_e *MockManager_Expecter) CronWithSeconds(cronExpression interface{}) *MockManager_CronWithSeconds_Call {
	return &MockManager_CronWithSeconds_Call{Call: _e.mock.On("CronWithSeconds", cronExpression)}
}

func (_c *MockManager_CronWithSeconds_Call) Run(run func(cronExpression string)) *MockManager_CronWithSeconds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockManager_CronWithSeconds_Call) Return(_a0 scheduler.Manager) *MockManager_CronWithSeconds_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_CronWithSeconds_Call) RunAndReturn(run func(string) scheduler.Manager) *MockManager_CronWithSeconds_Call {
	_c.Call.Return(run)
	return _c
}

// Days provides a mock function with no fields
func (_m *MockManager) Days() scheduler.Manager {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Days")
	}

	var r0 scheduler.Manager
	if rf, ok := ret.Get(0).(func() scheduler.Manager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(scheduler.Manager)
		}
	}

	return r0
}

// MockManager_Days_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Days'
type MockManager_Days_Call struct {
	*mock.Call
}

// Days is a helper method to define mock.On call
func (_e *MockManager_Expecter) Days() *MockManager_Days_Call {
	return &MockManager_Days_Call{Call: _e.mock.On("Days")}
}

func (_c *MockManager_Days_Call) Run(run func()) *MockManager_Days_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockManager_Days_Call) Return(_a0 scheduler.Manager) *MockManager_Days_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_Days_Call) RunAndReturn(run func() scheduler.Manager) *MockManager_Days_Call {
	_c.Call.Return(run)
	return _c
}

// Do provides a mock function with given fields: jobFun, params
func (_m *MockManager) Do(jobFun interface{}, params ...interface{}) (*gocron.Job, error) {
	var _ca []interface{}
	_ca = append(_ca, jobFun)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Do")
	}

	var r0 *gocron.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) (*gocron.Job, error)); ok {
		return rf(jobFun, params...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gocron.Job); ok {
		r0 = rf(jobFun, params...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocron.Job)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...interface{}) error); ok {
		r1 = rf(jobFun, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockManager_Do_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Do'
type MockManager_Do_Call struct {
	*mock.Call
}

// Do is a helper method to define mock.On call
//   - jobFun interface{}
//   - params ...interface{}
func (_e *MockManager_Expecter) Do(jobFun interface{}, params ...interface{}) *MockManager_Do_Call {
	return &MockManager_Do_Call{Call: _e.mock.On("Do",
		append([]interface{}{jobFun}, params...)...)}
}

func (_c *MockManager_Do_Call) Run(run func(jobFun interface{}, params ...interface{})) *MockManager_Do_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MockManager_Do_Call) Return(_a0 *gocron.Job, _a1 error) *MockManager_Do_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockManager_Do_Call) RunAndReturn(run func(interface{}, ...interface{}) (*gocron.Job, error)) *MockManager_Do_Call {
	_c.Call.Return(run)
	return _c
}

// Every provides a mock function with given fields: interval
func (_m *MockManager) Every(interval interface{}) scheduler.Manager {
	ret := _m.Called(interval)

	if len(ret) == 0 {
		panic("no return value specified for Every")
	}

	var r0 scheduler.Manager
	if rf, ok := ret.Get(0).(func(interface{}) scheduler.Manager); ok {
		r0 = rf(interval)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(scheduler.Manager)
		}
	}

	return r0
}

// MockManager_Every_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Every'
type MockManager_Every_Call struct {
	*mock.Call
}

// Every is a helper method to define mock.On call
//   - interval interface{}
func (_e *MockManager_Expecter) Every(interval interface{}) *MockManager_Every_Call {
	return &MockManager_Every_Call{Call: _e.mock.On("Every", interval)}
}

func (_c *MockManager_Every_Call) Run(run func(interval interface{})) *MockManager_Every_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *MockManager_Every_Call) Return(_a0 scheduler.Manager) *MockManager_Every_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_Every_Call) RunAndReturn(run func(interface{}) scheduler.Manager) *MockManager_Every_Call {
	_c.Call.Return(run)
	return _c
}

// FindJobsByTag provides a mock function with given fields: tags
func (_m *MockManager) FindJobsByTag(tags ...string) ([]*gocron.Job, error) {
	_va := make([]interface{}, len(tags))
	for _i := range tags {
		_va[_i] = tags[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindJobsByTag")
	}

	var r0 []*gocron.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(...string) ([]*gocron.Job, error)); ok {
		return rf(tags...)
	}
	if rf, ok := ret.Get(0).(func(...string) []*gocron.Job); ok {
		r0 = rf(tags...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocron.Job)
		}
	}

	if rf, ok := ret.Get(1).(func(...string) error); ok {
		r1 = rf(tags...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockManager_FindJobsByTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindJobsByTag'
type MockManager_FindJobsByTag_Call struct {
	*mock.Call
}

// FindJobsByTag is a helper method to define mock.On call
//   - tags ...string
func (_e *MockManager_Expecter) FindJobsByTag(tags ...interface{}) *MockManager_FindJobsByTag_Call {
	return &MockManager_FindJobsByTag_Call{Call: _e.mock.On("FindJobsByTag",
		append([]interface{}{}, tags...)...)}
}

func (_c *MockManager_FindJobsByTag_Call) Run(run func(tags ...string)) *MockManager_FindJobsByTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockManager_FindJobsByTag_Call) Return(_a0 []*gocron.Job, _a1 error) *MockManager_FindJobsByTag_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockManager_FindJobsByTag_Call) RunAndReturn(run func(...string) ([]*gocron.Job, error)) *MockManager_FindJobsByTag_Call {
	_c.Call.Return(run)
	return _c
}

// GetScheduler provides a mock function with no fields
func (_m *MockManager) GetScheduler() *gocron.Scheduler {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetScheduler")
	}

	var r0 *gocron.Scheduler
	if rf, ok := ret.Get(0).(func() *gocron.Scheduler); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocron.Scheduler)
		}
	}

	return r0
}

// MockManager_GetScheduler_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetScheduler'
type MockManager_GetScheduler_Call struct {
	*mock.Call
}

// GetScheduler is a helper method to define mock.On call
func (_e *MockManager_Expecter) GetScheduler() *MockManager_GetScheduler_Call {
	return &MockManager_GetScheduler_Call{Call: _e.mock.On("GetScheduler")}
}

func (_c *MockManager_GetScheduler_Call) Run(run func()) *MockManager_GetScheduler_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockManager_GetScheduler_Call) Return(_a0 *gocron.Scheduler) *MockManager_GetScheduler_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_GetScheduler_Call) RunAndReturn(run func() *gocron.Scheduler) *MockManager_GetScheduler_Call {
	_c.Call.Return(run)
	return _c
}

// Hours provides a mock function with no fields
func (_m *MockManager) Hours() scheduler.Manager {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Hours")
	}

	var r0 scheduler.Manager
	if rf, ok := ret.Get(0).(func() scheduler.Manager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(scheduler.Manager)
		}
	}

	return r0
}

// MockManager_Hours_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Hours'
type MockManager_Hours_Call struct {
	*mock.Call
}

// Hours is a helper method to define mock.On call
func (_e *MockManager_Expecter) Hours() *MockManager_Hours_Call {
	return &MockManager_Hours_Call{Call: _e.mock.On("Hours")}
}

func (_c *MockManager_Hours_Call) Run(run func()) *MockManager_Hours_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockManager_Hours_Call) Return(_a0 scheduler.Manager) *MockManager_Hours_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_Hours_Call) RunAndReturn(run func() scheduler.Manager) *MockManager_Hours_Call {
	_c.Call.Return(run)
	return _c
}

// IsRunning provides a mock function with no fields
func (_m *MockManager) IsRunning() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsRunning")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockManager_IsRunning_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsRunning'
type MockManager_IsRunning_Call struct {
	*mock.Call
}

// IsRunning is a helper method to define mock.On call
func (_e *MockManager_Expecter) IsRunning() *MockManager_IsRunning_Call {
	return &MockManager_IsRunning_Call{Call: _e.mock.On("IsRunning")}
}

func (_c *MockManager_IsRunning_Call) Run(run func()) *MockManager_IsRunning_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockManager_IsRunning_Call) Return(_a0 bool) *MockManager_IsRunning_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_IsRunning_Call) RunAndReturn(run func() bool) *MockManager_IsRunning_Call {
	_c.Call.Return(run)
	return _c
}

// Minutes provides a mock function with no fields
func (_m *MockManager) Minutes() scheduler.Manager {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Minutes")
	}

	var r0 scheduler.Manager
	if rf, ok := ret.Get(0).(func() scheduler.Manager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(scheduler.Manager)
		}
	}

	return r0
}

// MockManager_Minutes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Minutes'
type MockManager_Minutes_Call struct {
	*mock.Call
}

// Minutes is a helper method to define mock.On call
func (_e *MockManager_Expecter) Minutes() *MockManager_Minutes_Call {
	return &MockManager_Minutes_Call{Call: _e.mock.On("Minutes")}
}

func (_c *MockManager_Minutes_Call) Run(run func()) *MockManager_Minutes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockManager_Minutes_Call) Return(_a0 scheduler.Manager) *MockManager_Minutes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_Minutes_Call) RunAndReturn(run func() scheduler.Manager) *MockManager_Minutes_Call {
	_c.Call.Return(run)
	return _c
}

// Name provides a mock function with given fields: name
func (_m *MockManager) Name(name string) scheduler.Manager {
	ret := _m.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 scheduler.Manager
	if rf, ok := ret.Get(0).(func(string) scheduler.Manager); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(scheduler.Manager)
		}
	}

	return r0
}

// MockManager_Name_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Name'
type MockManager_Name_Call struct {
	*mock.Call
}

// Name is a helper method to define mock.On call
//   - name string
func (_e *MockManager_Expecter) Name(name interface{}) *MockManager_Name_Call {
	return &MockManager_Name_Call{Call: _e.mock.On("Name", name)}
}

func (_c *MockManager_Name_Call) Run(run func(name string)) *MockManager_Name_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockManager_Name_Call) Return(_a0 scheduler.Manager) *MockManager_Name_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_Name_Call) RunAndReturn(run func(string) scheduler.Manager) *MockManager_Name_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterEventListeners provides a mock function with given fields: eventListeners
func (_m *MockManager) RegisterEventListeners(eventListeners ...gocron.EventListener) {
	_va := make([]interface{}, len(eventListeners))
	for _i := range eventListeners {
		_va[_i] = eventListeners[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MockManager_RegisterEventListeners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterEventListeners'
type MockManager_RegisterEventListeners_Call struct {
	*mock.Call
}

// RegisterEventListeners is a helper method to define mock.On call
//   - eventListeners ...gocron.EventListener
func (_e *MockManager_Expecter) RegisterEventListeners(eventListeners ...interface{}) *MockManager_RegisterEventListeners_Call {
	return &MockManager_RegisterEventListeners_Call{Call: _e.mock.On("RegisterEventListeners",
		append([]interface{}{}, eventListeners...)...)}
}

func (_c *MockManager_RegisterEventListeners_Call) Run(run func(eventListeners ...gocron.EventListener)) *MockManager_RegisterEventListeners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gocron.EventListener, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(gocron.EventListener)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockManager_RegisterEventListeners_Call) Return() *MockManager_RegisterEventListeners_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockManager_RegisterEventListeners_Call) RunAndReturn(run func(...gocron.EventListener)) *MockManager_RegisterEventListeners_Call {
	_c.Run(run)
	return _c
}

// RemoveByTag provides a mock function with given fields: tag
func (_m *MockManager) RemoveByTag(tag string) error {
	ret := _m.Called(tag)

	if len(ret) == 0 {
		panic("no return value specified for RemoveByTag")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(tag)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockManager_RemoveByTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveByTag'
type MockManager_RemoveByTag_Call struct {
	*mock.Call
}

// RemoveByTag is a helper method to define mock.On call
//   - tag string
func (_e *MockManager_Expecter) RemoveByTag(tag interface{}) *MockManager_RemoveByTag_Call {
	return &MockManager_RemoveByTag_Call{Call: _e.mock.On("RemoveByTag", tag)}
}

func (_c *MockManager_RemoveByTag_Call) Run(run func(tag string)) *MockManager_RemoveByTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockManager_RemoveByTag_Call) Return(_a0 error) *MockManager_RemoveByTag_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_RemoveByTag_Call) RunAndReturn(run func(string) error) *MockManager_RemoveByTag_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveByTags provides a mock function with given fields: tags
func (_m *MockManager) RemoveByTags(tags ...string) error {
	_va := make([]interface{}, len(tags))
	for _i := range tags {
		_va[_i] = tags[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveByTags")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(...string) error); ok {
		r0 = rf(tags...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockManager_RemoveByTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveByTags'
type MockManager_RemoveByTags_Call struct {
	*mock.Call
}

// RemoveByTags is a helper method to define mock.On call
//   - tags ...string
func (_e *MockManager_Expecter) RemoveByTags(tags ...interface{}) *MockManager_RemoveByTags_Call {
	return &MockManager_RemoveByTags_Call{Call: _e.mock.On("RemoveByTags",
		append([]interface{}{}, tags...)...)}
}

func (_c *MockManager_RemoveByTags_Call) Run(run func(tags ...string)) *MockManager_RemoveByTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockManager_RemoveByTags_Call) Return(_a0 error) *MockManager_RemoveByTags_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_RemoveByTags_Call) RunAndReturn(run func(...string) error) *MockManager_RemoveByTags_Call {
	_c.Call.Return(run)
	return _c
}

// Second provides a mock function with no fields
func (_m *MockManager) Second() scheduler.Manager {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Second")
	}

	var r0 scheduler.Manager
	if rf, ok := ret.Get(0).(func() scheduler.Manager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(scheduler.Manager)
		}
	}

	return r0
}

// MockManager_Second_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Second'
type MockManager_Second_Call struct {
	*mock.Call
}

// Second is a helper method to define mock.On call
func (_e *MockManager_Expecter) Second() *MockManager_Second_Call {
	return &MockManager_Second_Call{Call: _e.mock.On("Second")}
}

func (_c *MockManager_Second_Call) Run(run func()) *MockManager_Second_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockManager_Second_Call) Return(_a0 scheduler.Manager) *MockManager_Second_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_Second_Call) RunAndReturn(run func() scheduler.Manager) *MockManager_Second_Call {
	_c.Call.Return(run)
	return _c
}

// Seconds provides a mock function with no fields
func (_m *MockManager) Seconds() scheduler.Manager {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Seconds")
	}

	var r0 scheduler.Manager
	if rf, ok := ret.Get(0).(func() scheduler.Manager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(scheduler.Manager)
		}
	}

	return r0
}

// MockManager_Seconds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Seconds'
type MockManager_Seconds_Call struct {
	*mock.Call
}

// Seconds is a helper method to define mock.On call
func (_e *MockManager_Expecter) Seconds() *MockManager_Seconds_Call {
	return &MockManager_Seconds_Call{Call: _e.mock.On("Seconds")}
}

func (_c *MockManager_Seconds_Call) Run(run func()) *MockManager_Seconds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockManager_Seconds_Call) Return(_a0 scheduler.Manager) *MockManager_Seconds_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_Seconds_Call) RunAndReturn(run func() scheduler.Manager) *MockManager_Seconds_Call {
	_c.Call.Return(run)
	return _c
}

// SingletonMode provides a mock function with no fields
func (_m *MockManager) SingletonMode() scheduler.Manager {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for SingletonMode")
	}

	var r0 scheduler.Manager
	if rf, ok := ret.Get(0).(func() scheduler.Manager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(scheduler.Manager)
		}
	}

	return r0
}

// MockManager_SingletonMode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SingletonMode'
type MockManager_SingletonMode_Call struct {
	*mock.Call
}

// SingletonMode is a helper method to define mock.On call
func (_e *MockManager_Expecter) SingletonMode() *MockManager_SingletonMode_Call {
	return &MockManager_SingletonMode_Call{Call: _e.mock.On("SingletonMode")}
}

func (_c *MockManager_SingletonMode_Call) Run(run func()) *MockManager_SingletonMode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockManager_SingletonMode_Call) Return(_a0 scheduler.Manager) *MockManager_SingletonMode_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_SingletonMode_Call) RunAndReturn(run func() scheduler.Manager) *MockManager_SingletonMode_Call {
	_c.Call.Return(run)
	return _c
}

// StartAsync provides a mock function with no fields
func (_m *MockManager) StartAsync() {
	_m.Called()
}

// MockManager_StartAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartAsync'
type MockManager_StartAsync_Call struct {
	*mock.Call
}

// StartAsync is a helper method to define mock.On call
func (_e *MockManager_Expecter) StartAsync() *MockManager_StartAsync_Call {
	return &MockManager_StartAsync_Call{Call: _e.mock.On("StartAsync")}
}

func (_c *MockManager_StartAsync_Call) Run(run func()) *MockManager_StartAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockManager_StartAsync_Call) Return() *MockManager_StartAsync_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockManager_StartAsync_Call) RunAndReturn(run func()) *MockManager_StartAsync_Call {
	_c.Run(run)
	return _c
}

// StartAt provides a mock function with given fields: _a0
func (_m *MockManager) StartAt(_a0 time.Time) scheduler.Manager {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for StartAt")
	}

	var r0 scheduler.Manager
	if rf, ok := ret.Get(0).(func(time.Time) scheduler.Manager); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(scheduler.Manager)
		}
	}

	return r0
}

// MockManager_StartAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartAt'
type MockManager_StartAt_Call struct {
	*mock.Call
}

// StartAt is a helper method to define mock.On call
//   - _a0 time.Time
func (_e *MockManager_Expecter) StartAt(_a0 interface{}) *MockManager_StartAt_Call {
	return &MockManager_StartAt_Call{Call: _e.mock.On("StartAt", _a0)}
}

func (_c *MockManager_StartAt_Call) Run(run func(_a0 time.Time)) *MockManager_StartAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Time))
	})
	return _c
}

func (_c *MockManager_StartAt_Call) Return(_a0 scheduler.Manager) *MockManager_StartAt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_StartAt_Call) RunAndReturn(run func(time.Time) scheduler.Manager) *MockManager_StartAt_Call {
	_c.Call.Return(run)
	return _c
}

// StartBlocking provides a mock function with no fields
func (_m *MockManager) StartBlocking() {
	_m.Called()
}

// MockManager_StartBlocking_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartBlocking'
type MockManager_StartBlocking_Call struct {
	*mock.Call
}

// StartBlocking is a helper method to define mock.On call
func (_e *MockManager_Expecter) StartBlocking() *MockManager_StartBlocking_Call {
	return &MockManager_StartBlocking_Call{Call: _e.mock.On("StartBlocking")}
}

func (_c *MockManager_StartBlocking_Call) Run(run func()) *MockManager_StartBlocking_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockManager_StartBlocking_Call) Return() *MockManager_StartBlocking_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockManager_StartBlocking_Call) RunAndReturn(run func()) *MockManager_StartBlocking_Call {
	_c.Run(run)
	return _c
}

// Stop provides a mock function with no fields
func (_m *MockManager) Stop() {
	_m.Called()
}

// MockManager_Stop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stop'
type MockManager_Stop_Call struct {
	*mock.Call
}

// Stop is a helper method to define mock.On call
func (_e *MockManager_Expecter) Stop() *MockManager_Stop_Call {
	return &MockManager_Stop_Call{Call: _e.mock.On("Stop")}
}

func (_c *MockManager_Stop_Call) Run(run func()) *MockManager_Stop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockManager_Stop_Call) Return() *MockManager_Stop_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockManager_Stop_Call) RunAndReturn(run func()) *MockManager_Stop_Call {
	_c.Run(run)
	return _c
}

// Tag provides a mock function with given fields: tags
func (_m *MockManager) Tag(tags ...string) scheduler.Manager {
	_va := make([]interface{}, len(tags))
	for _i := range tags {
		_va[_i] = tags[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Tag")
	}

	var r0 scheduler.Manager
	if rf, ok := ret.Get(0).(func(...string) scheduler.Manager); ok {
		r0 = rf(tags...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(scheduler.Manager)
		}
	}

	return r0
}

// MockManager_Tag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Tag'
type MockManager_Tag_Call struct {
	*mock.Call
}

// Tag is a helper method to define mock.On call
//   - tags ...string
func (_e *MockManager_Expecter) Tag(tags ...interface{}) *MockManager_Tag_Call {
	return &MockManager_Tag_Call{Call: _e.mock.On("Tag",
		append([]interface{}{}, tags...)...)}
}

func (_c *MockManager_Tag_Call) Run(run func(tags ...string)) *MockManager_Tag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockManager_Tag_Call) Return(_a0 scheduler.Manager) *MockManager_Tag_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_Tag_Call) RunAndReturn(run func(...string) scheduler.Manager) *MockManager_Tag_Call {
	_c.Call.Return(run)
	return _c
}

// Weeks provides a mock function with no fields
func (_m *MockManager) Weeks() scheduler.Manager {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Weeks")
	}

	var r0 scheduler.Manager
	if rf, ok := ret.Get(0).(func() scheduler.Manager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(scheduler.Manager)
		}
	}

	return r0
}

// MockManager_Weeks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Weeks'
type MockManager_Weeks_Call struct {
	*mock.Call
}

// Weeks is a helper method to define mock.On call
func (_e *MockManager_Expecter) Weeks() *MockManager_Weeks_Call {
	return &MockManager_Weeks_Call{Call: _e.mock.On("Weeks")}
}

func (_c *MockManager_Weeks_Call) Run(run func()) *MockManager_Weeks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockManager_Weeks_Call) Return(_a0 scheduler.Manager) *MockManager_Weeks_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_Weeks_Call) RunAndReturn(run func() scheduler.Manager) *MockManager_Weeks_Call {
	_c.Call.Return(run)
	return _c
}

// WithDistributedLocker provides a mock function with given fields: locker
func (_m *MockManager) WithDistributedLocker(locker gocron.Locker) scheduler.Manager {
	ret := _m.Called(locker)

	if len(ret) == 0 {
		panic("no return value specified for WithDistributedLocker")
	}

	var r0 scheduler.Manager
	if rf, ok := ret.Get(0).(func(gocron.Locker) scheduler.Manager); ok {
		r0 = rf(locker)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(scheduler.Manager)
		}
	}

	return r0
}

// MockManager_WithDistributedLocker_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithDistributedLocker'
type MockManager_WithDistributedLocker_Call struct {
	*mock.Call
}

// WithDistributedLocker is a helper method to define mock.On call
//   - locker gocron.Locker
func (_e *MockManager_Expecter) WithDistributedLocker(locker interface{}) *MockManager_WithDistributedLocker_Call {
	return &MockManager_WithDistributedLocker_Call{Call: _e.mock.On("WithDistributedLocker", locker)}
}

func (_c *MockManager_WithDistributedLocker_Call) Run(run func(locker gocron.Locker)) *MockManager_WithDistributedLocker_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gocron.Locker))
	})
	return _c
}

func (_c *MockManager_WithDistributedLocker_Call) Return(_a0 scheduler.Manager) *MockManager_WithDistributedLocker_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockManager_WithDistributedLocker_Call) RunAndReturn(run func(gocron.Locker) scheduler.Manager) *MockManager_WithDistributedLocker_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockManager creates a new instance of MockManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockManager {
	mock := &MockManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
